rd_("o<code>as</code>n<code>@</code>o<code>do</code>BgThe <code>==</code> operator (equality)n<code>=</code>o<code>fn</code>CjThe <code>&gt;=</code> operator (greater than or equal to)Ab<code>&gt;=</code>BmThe <code>&gt;</code> operator (greater than)Aa<code>&gt;</code>DkAn <code>if</code> expression with an optional <code>else</code> block: \xe2\x80\xa6o<code>if</code>o<code>in</code>CgThe <code>&lt;=</code> operator (less than or equal to)Ab<code>&lt;=</code>BjThe <code>&lt;</code> operator (less than)Aa<code>&lt;</code>BkThe <code>!=</code> operator (not equal to)o<code>!=</code>AjContains the success value0BiThe <code>||</code> operator (logical or)n<code>|</code>DfThe binary interface of a function: <code>extern &quot;C&quot;</code>.BfThe <code>+</code> operator (addition)CbThe <code>&amp;&amp;</code> operator (logical and)Ab<code>&amp;</code>A`<code>box</code>BfThe <code>/</code> operator (division)n<code>.</code>A`<code>dyn</code>ChPseudo-token used for peeking the end of a parse stream.AhContains the error value0A`<code>for</code>ChAn integer literal: <code>1</code> or <code>1u16</code>.CiA <code>let</code> guard: <code>let Some(x) = opt</code>.A`<code>let</code>EbA literal in place of an expression: <code>1</code>, <code>&quot;foo&quot;</code>.CfA Rust literal such as a string or integer or boolean.A`<code>mod</code>BlThe <code>*</code> operator (multiplication)A`<code>mut</code>BhThe <code>-</code> operator for negationCaThe <code>!</code> operator for logical inversionn<code>!</code>DaA raw pointer type: <code>*const T</code> or <code>*mut T</code>.A`<code>pub</code>A`<code>raw</code>A`<code>ref</code>BeThe <code>%</code> operator (modulus)BoThe <code>&lt;&lt;</code> operator (shift left)Ae<code>&lt;&lt;</code>C`The <code>&gt;&gt;</code> operator (shift right)Ae<code>&gt;&gt;</code>CeA UTF-8 string literal: <code>&quot;foo&quot;</code>.BiThe <code>-</code> operator (subtraction)BeA try-expression: <code>expr?</code>.A`<code>try</code>A`<code>use</code>CnChecks whether the cursor is currently pointing at the end \xe2\x80\xa6CjExtension traits to provide parsing methods on foreign \xe2\x80\xa6BlFormat this value as an identifier fragment.BgBorrows the element at the given index.AmReturns the number of fields.CnReturns the number of syntax tree nodes in this punctuated \xe2\x80\xa6DdReturns an empty <code>TokenStream</code> containing no token trees.DgCreates a new <code>Group</code> with the given delimiter and token \xe2\x80\xa6DfCreates a new <code>Punct</code> from the given character and spacing.EfCreates a new <code>Ident</code> with the given <code>string</code> as well as the \xe2\x80\xa6DcUsually the <code>ParseStream::error</code> method will be used \xe2\x80\xa61fPanicsCcInterpret a Syn literal from a proc-macro2 literal.DiCreates a <code>TokenBuffer</code> containing all the tokens from the \xe2\x80\xa6BeCreates an empty punctuated sequence.CnCreates a punctuated pair out of a syntax tree node and an \xe2\x80\xa6CkRemoves the last punctuated pair from this sequence, or \xe2\x80\xa6Algithub\xe2\x80\x82crates-io\xe2\x80\x82docs-rsAa<code>auto</code>CkA boolean literal: <code>true</code> or <code>false</code>.BjA byte literal: <code>b&#39;f&#39;</code>.DaA nul-terminated C-string literal: <code>c&quot;foo&quot;</code>.CfA function call expression: <code>invoke(a, b)</code>.BkA cast expression: <code>foo as f64</code>.BnA character literal: <code>&#39;a&#39;</code>.CfThe storage of a struct, enum or union data structure.Aa<code>else</code>Aa<code>enum</code>o<code>==</code>AbA Rust expression.Aa<code>impl</code>CmAn iterator over borrowed values of type <code>&amp;T</code>.BoA structured list within an attribute, like \xe2\x80\xa6BnConditionless loop: <code>loop { ... }</code>.Aa<code>loop</code>BoContent of a compile-time structured attribute.Aa<code>move</code>Ah<code>\xe2\x88\x85 ... \xe2\x88\x85</code>o<code>|=</code>o<code>||</code>DdA single syntax tree node of type <code>T</code> followed by its \xe2\x80\xa6DkA path like <code>core::mem::replace</code> possibly containing generic \xe2\x80\xa6DkA path like <code>core::slice::Iter</code>, optionally qualified with a \xe2\x80\xa6CbA path at which a named item is exported (e.g. \xe2\x80\xa6CfTypes that can be parsed by looking at just one token.n<code>+</code>Aa<code>priv</code>n<code>;</code>CgA region of source code, along with macro expansion \xe2\x80\xa6n<code>*</code>CmA generic type parameter: <code>T: Into&lt;String&gt;</code>.CdA type predicate in a <code>where</code> clause: \xe2\x80\xa6A`A type argument.AnA particular type is returned.C`The possible types that a Rust value could have.Aa<code>type</code>DaA unary operator: <code>*</code>, <code>!</code>, <code>-</code>.CfUnit struct or unit variant such as <code>None</code>.CjCalls the given parser function to parse a syntax tree \xe2\x80\xa6CmForks a parse stream so that parsing tokens out of either \xe2\x80\xa6AoReturns the argument unchanged.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000BaCalls <code>U::from(self)</code>.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000DfGet an iterator over the borrowed <code>Field</code> items in this \xe2\x80\xa6CjReturns an iterator over borrowed syntax tree nodes of \xe2\x80\xa6DhCreate a new span encompassing <code>self</code> and <code>other</code>.CcReturns a span covering the entire delimited group.BjBorrows the last element in this sequence.CmFacility for interpreting structured content inside of an \xe2\x80\xa6DiCreates a <code>TokenBuffer</code> containing all the tokens from the \xe2\x80\xa6CkReturns a span for the opening punctuation of the group \xe2\x80\xa6CjReturns the path that identifies the interpretation of \xe2\x80\xa6CgReturns the path that begins this structured meta item.FdThe <code>Foo&lt;&amp;&#39;a T&gt;</code> in <code>for&lt;&#39;a&gt; Foo&lt;&amp;&#39;a T&gt;</code>CmReturns whether the next token in the parse stream is one \xe2\x80\xa6ClLooks at the next token in the parse stream to determine \xe2\x80\xa60CnAppends a syntax tree node onto the end of this punctuated \xe2\x80\xa6DfReturns the span of this tree, delegating to the <code>span</code> \xe2\x80\xa6CmReturns the span for the delimiters of this token stream, \xe2\x80\xa6C`Returns the span for this punctuation character.BlReturns the span of this <code>Ident</code>.BkReturns the span encompassing this literal.CeSpan associated with this <code>IdentFragment</code>.0BaThe source location of the error.3EhReturns the <code>Span</code> of the current token, or <code>Span::call_site()</code>\xe2\x80\xa6DkReturns the <code>Span</code> of the next token in the parse stream, or \xe2\x80\xa6DfReturns a <code>Span</code> covering the complete contents of this \xe2\x80\xa6CgSpeculatively parses tokens from this parse stream, \xe2\x80\xa6FgE.g. <code>+</code> is <code>Alone</code> in <code>+ =</code>, <code>+ident</code> or <code>+()</code>.Ac<code>&amp;=</code>CfA slice literal expression: <code>[a, b, c, d]</code>.BmA fixed size array type: <code>[T; n]</code>.BkAn async block: <code>async { ... }</code>.Ab<code>async</code>BlAn await expression: <code>fut.await</code>.Ab<code>await</code>DgA binary operator: <code>+</code>, <code>+=</code>, <code>&amp;</code>.BhThe <code>|</code> operator (bitwise or)BfA blocked scope: <code>{ ... }</code>.Ad<code>{ ... }</code>Ao<code>{</code>\xe2\x80\xa6<code>}</code>DiA <code>break</code>, with an optional label to break and an optional \xe2\x80\xa6Ab<code>break</code>n<code>^</code>n<code>:</code>n<code>,</code>BjA const block: <code>const { ... }</code>.ClA const generic parameter: <code>const LENGTH: usize</code>.BnA const expression. Must be inside of a block.Ab<code>const</code>Ab<code>crate</code>BmThe <code>*</code> operator for dereferencingCkError returned when a Syn parser cannot parse the input \xe2\x80\xa60DhAccess of a named struct field (<code>obj.k</code>) or unnamed tuple \xe2\x80\xa6BdA field of a struct or enum variant.Ab<code>final</code>DfA floating point literal: <code>1f64</code> or <code>1.0e10f64</code>.C`A token stream surrounded by bracket delimiters.AiA delimited token stream.CdAn expression contained within invisible delimiters.BmA type contained within invisible delimiters.AdNone-delimited groupnAn identifier.ChA word of Rust code, which may be a keyword or legal \xe2\x80\xa60CoA square bracketed indexing expression: <code>vector[2]</code>.BkThe index of an unnamed tuple struct field.DgThe inferred value of a const generic argument, denoted <code>_</code>.CnIndication that a type should be inferred by the compiler: \xe2\x80\xa6H`E.g. <code>+</code> is <code>Joint</code> in <code>+=</code> or <code>&#39;</code> is <code>Joint</code> in <code>&#39;#</code>.DgA macro invocation expression: <code>format!(&quot;{}&quot;, q)</code>.AmA macro in the type position.CoA macro invocation: <code>println!(&quot;{}&quot;, mac)</code>.Ab<code>macro</code>EjA <code>match</code> expression: <code>match n { Some(n) =&gt; {}, None =&gt; {} }</code>.Ab<code>match</code>n<code>-</code>CfNamed fields of a struct or struct variant such as \xe2\x80\xa6BgA named field like <code>self.x</code>.AoThe never type: <code>!</code>.E`An iterator over borrowed pairs of type <code>Pair&lt;&amp;T, &amp;P&gt;</code>.CaA parenthesized expression: <code>(a + b)</code>.CbA parenthesized type equivalent to the inner type.Ao<code>(</code>\xe2\x80\xa6<code>)</code>CjParsing interface implemented by all types that can be \xe2\x80\xa6n<code>#</code>EfA single punctuation character (<code>+</code>, <code>,</code>, <code>$</code>, etc.).FmA <code>Punct</code> is a single punctuation character like <code>+</code>, <code>-</code> or <code>#</code>.DeThe explicit Self type in a qualified path: the <code>T</code> in \xe2\x80\xa6GaA range expression: <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>.Af<code>&lt;&lt;=</code>Af<code>&gt;&gt;=</code>n<code>/</code>CaA dynamically sized slice type: <code>[T]</code>.Ab<code>super</code>n<code>~</code>CjA type-macro that expands to the name of the Rust type \xe2\x80\xa6CdMarker trait for types that represent single tokens.Ab<code>trait</code>BnA tuple expression: <code>(a, b, c, d)</code>.BmA tuple type: <code>(A, B, C, String)</code>.CdA unary operation: <code>!x</code>, <code>*x</code>.Ab<code>union</code>Ab<code>where</code>BnA while loop: <code>while expr { ... }</code>.Ab<code>while</code>BlA yield expression: <code>yield expr</code>.Ab<code>yield</code>CnCreates a cursor referencing the first token in the buffer \xe2\x80\xa6CmClears the sequence of all values and punctuation, making \xe2\x80\xa6CkReturns a span for the closing punctuation of the group \xe2\x80\xa6ChCreates a cursor referencing a static empty TokenStream.ClReport that the attribute\xe2\x80\x99s content did not conform to \xe2\x80\xa6CjTriggers an error at the current position of the parse \xe2\x80\xa600CnItems which do not have a correspondence to any API in the \xe2\x80\xa6BkBorrows the first element in this sequence.DdIf the cursor is pointing at a <code>Group</code> with the given \xe2\x80\xa6AdName of the variant.AjName of the field, if any.DgIf the cursor is pointing at a <code>Ident</code>, returns it along \xe2\x80\xa6CmReturns an iterator over the contents of this sequence as \xe2\x80\xa6CnParsing interface for parsing a token stream into a syntax \xe2\x80\xa6CkParse tokens of source code into the chosen syntax tree \xe2\x80\xa6ClParse a syntax tree node from the content of this string \xe2\x80\xa6DcParses a syntax tree node of type <code>T</code>, advancing the \xe2\x80\xa62CcLooks at the second-next token in the parse stream.CbLooks at the third-next token in the parse stream.DgIf the cursor is pointing at a <code>Punct</code>, returns it along \xe2\x80\xa6CmBorrows the punctuation from this punctuated pair, unless \xe2\x80\xa6Algithub\xe2\x80\x82crates-io\xe2\x80\x82docs-rsA`The whole point.CgTokens representing Rust punctuation, keywords, and \xe2\x80\xa6DkStrips the raw marker <code>r#</code>, if any, from the beginning of an \xe2\x80\xa6CnUsed when parsing <code>key = &quot;value&quot;</code> syntax.CgBorrows the syntax tree node from this punctuated pair.Ag<code>&amp;&amp;</code>CeAn assignment expression: <code>a = compute()</code>.ChA bare function type: <code>fn(usize) -&gt; bool</code>.Ac<code>become</code>ClA binary operation: <code>a + b</code>, <code>a += b</code>.BmThe <code>&amp;</code> operator (bitwise and)BiThe <code>^</code> operator (bitwise xor)CjA cheaply copyable cursor into a <code>TokenBuffer</code>.n<code>$</code>o<code>..</code>DkAn <code>if</code> expression with an optional <code>else</code> block: \xe2\x80\xa6Ac<code>extern</code>BmData stored within an enum variant or struct.Ab<code>&lt;-</code>ChAn integer literal: <code>1</code> or <code>1u16</code>.CeA UTF-8 string literal: <code>&quot;foo&quot;</code>.CgA struct or tuple struct field accessed in a struct \xe2\x80\xa6CnParser that can parse Rust tokens into a particular syntax \xe2\x80\xa6o<code>+=</code>BlA public visibility level: <code>pub</code>.Ab<code>-&gt;</code>CkAn array literal constructed from one repeated element: \xe2\x80\xa6AkThe result of a Syn parser.0CmA <code>return</code>, with an optional value to be returned.Ac<code>return</code>o<code>*=</code>Ac<code>static</code>CoA struct literal expression: <code>Point { x: 1, y: 1 }</code>.Ac<code>struct</code>Ac<code>typeof</code>BmAn unsafe block: <code>unsafe { ... }</code>.Ac<code>unsafe</code>CaFor use by <code>ToTokens</code> implementations.CoTrait and lifetime bounds (<code>Clone+Send+&#39;static</code>)CkParse a set of curly braces and expose their content to \xe2\x80\xa6ChA stably addressed token buffer supporting efficient \xe2\x80\xa6CiProvides low-level access to the token representation \xe2\x80\xa6AnContent stored in the variant.Ac<code>(A, B)</code>CbInserts an element at position <code>index</code>.n<code>C</code>CkParse a proc-macro2 token stream into the chosen syntax \xe2\x80\xa60DjMake a parser that is usable with <code>parse_macro_input!</code> in a \xe2\x80\xa6DhReturns the <code>TokenStream</code> of tokens that are delimited in \xe2\x80\xa6oString literal.DhConvert <code>proc_macro2::Span</code> to <code>proc_macro::Span</code>.Ad<code>[ ... ]</code>Ao<code>[</code>\xe2\x80\xa6<code>]</code>CeA byte string literal: <code>b&quot;foo&quot;</code>.o<code>^=</code>C`A closure expression: <code>|a, b| a + b</code>.AmReturn type is not specified.Ad<code>default</code>CiA <code>let</code> guard: <code>let Some(x) = opt</code>.EbA literal in place of an expression: <code>1</code>, <code>&quot;foo&quot;</code>.BeA try-expression: <code>expr?</code>.CaA for loop: <code>for pat in expr { ... }</code>.DiAn iterator over mutably borrowed values of type <code>&amp;mut T</code>.CkA boolean literal: <code>true</code> or <code>false</code>.BjA byte literal: <code>b&#39;f&#39;</code>.DaA nul-terminated C-string literal: <code>c&quot;foo&quot;</code>.BnA character literal: <code>&#39;a&#39;</code>.GgA literal character (<code>&#39;a&#39;</code>), string (<code>&quot;hello&quot;</code>), number (<code>2.3</code>), \xe2\x80\xa6FeA literal string (<code>&quot;hello&quot;</code>), byte string (<code>b&quot;hello&quot;</code>), \xe2\x80\xa6o<code>-=</code>CjAn empty syntax tree node that consumes no tokens when \xe2\x80\xa6o<code>::</code>n<code>%</code>EkAddress-of operation: <code>&amp;raw const place</code> or <code>&amp;raw mut place</code>.o<code>/=</code>EfWhether a <code>Punct</code> is followed immediately by another <code>Punct</code> \xe2\x80\xa6DkA trait that can provide the <code>Span</code> of the complete contents \xe2\x80\xa6DaA raw pointer type: <code>*const T</code> or <code>*mut T</code>.CmUnnamed fields of a tuple struct or tuple variant such as \xe2\x80\xa6BjAn unnamed field like <code>self.0</code>.Ad<code>unsized</code>A`An enum variant.Ad<code>virtual</code>DeReturns the value of this punctuation character as <code>char</code>.CdAdd another error message to self such that when \xe2\x80\xa6BoMutably borrows the element at the given index.DhIf the cursor is pointing at a <code>Literal</code>, return it along \xe2\x80\xa6CmGet an iterator over the fields of a struct or variant as \xe2\x80\xa6EfSame as <code>Ident::new</code>, but creates a raw identifier (<code>r#ident</code>\xe2\x80\xa60CfReturns the spacing of this punctuation character, \xe2\x80\xa6=EgReturns a <code>Span</code> that is a subset of <code>self.span()</code> containing \xe2\x80\xa6Ae<code>abstract</code>C`A <code>continue</code>, with an optional label.Ae<code>continue</code>ChAn enum input to a <code>proc_macro_derive</code> macro.A`<code>..=</code>CfA function call expression: <code>invoke(a, b)</code>.BkA cast expression: <code>foo as f64</code>.BnConditionless loop: <code>loop { ... }</code>.DkA path like <code>core::mem::replace</code> possibly containing generic \xe2\x80\xa6Ab<code>=&gt;</code>CnLifetimes and type parameters attached to a declaration of \xe2\x80\xa6DiAdditional methods for <code>Ident</code> not provided by proc-macro2 \xe2\x80\xa6DfAn iterator over <code>TokenStream</code>\xe2\x80\x99s <code>TokenTree</code>s.CeAn iterator over owned values of type <code>T</code>.CgError returned from <code>TokenStream::from_str</code>.DdA lifetime parameter: <code>&#39;a: &#39;b + &#39;c + &#39;d</code>.EjA lifetime predicate in a <code>where</code> clause: <code>&#39;a: &#39;b + &#39;c</code>.AdA lifetime argument.BeA Rust lifetime: <code>&#39;a</code>.DfA floating point literal: <code>1f64</code> or <code>1.0e10f64</code>.BoA structured list within an attribute, like \xe2\x80\xa6Ae<code>override</code>CcAn iterator over mutably borrowed pairs of type \xe2\x80\xa6n<code>?</code>Aa<code>Self</code>DgTypes that can be interpolated inside a <code>quote!</code> invocation.BfA try block: <code>try { ... }</code>.DkA path like <code>core::slice::Iter</code>, optionally qualified with a \xe2\x80\xa6CeTokens in expression position not interpreted by Syn.BkA raw token literal not interpreted by Syn.BoTokens in type position not interpreted by Syn.AaC string literal.CaChecks if this <code>TokenStream</code> is empty.CcReturns <code>true</code> if there are zero fields.ClReturns whether there are no more tokens remaining to be \xe2\x80\xa6CiDetermines whether this punctuated sequence is empty, \xe2\x80\xa6CnDetermines whether this is a path of length 1 equal to the \xe2\x80\xa6DiGet an iterator over the mutably borrowed <code>Field</code> items in \xe2\x80\xa6CiReturns an iterator over mutably borrowed syntax tree \xe2\x80\xa6CbMutably borrows the last element in this sequence.DjIf the cursor is pointing at a <code>Lifetime</code>, returns it along \xe2\x80\xa6CcPeeks any identifier including keywords. Usage: \xe2\x80\xa6CaConfigures the span for <em>only this token</em>.DkConfigures the span for this <code>Group</code>\xe2\x80\x99s delimiters, but not \xe2\x80\xa6CbConfigure the span for this punctuation character.DiConfigures the span of this <code>Ident</code>, possibly changing its \xe2\x80\xa6C`Configures the span associated for this literal.1AlThe <code>+=</code> operatorCnA binding (equality constraint) on an associated type: the \xe2\x80\xa60CnDistinguishes between attributes that decorate an item and \xe2\x80\xa6CeAn attribute, like <code>#[repr(transparent)]</code>.CmAn argument in a function type: the <code>usize</code> in \xe2\x80\xa6DbAn untagged union input to a <code>proc_macro_derive</code> macro.DnAn object that holds a <code>Group</code>\xe2\x80\x99s <code>span_open()</code> and \xe2\x80\xa6CeDescribes how a sequence of token trees is delimited.AlThe <code>/=</code> operatorA`<code>...</code>CfA slice literal expression: <code>[a, b, c, d]</code>.BkAn async block: <code>async { ... }</code>.BlAn await expression: <code>fut.await</code>.BfA blocked scope: <code>{ ... }</code>.DiA <code>break</code>, with an optional label to break and an optional \xe2\x80\xa6BjA const block: <code>const { ... }</code>.DhAccess of a named struct field (<code>obj.k</code>) or unnamed tuple \xe2\x80\xa6CdAn expression contained within invisible delimiters.CoA square bracketed indexing expression: <code>vector[2]</code>.DgThe inferred value of a const generic argument, denoted <code>_</code>.DgA macro invocation expression: <code>format!(&quot;{}&quot;, q)</code>.EjA <code>match</code> expression: <code>match n { Some(n) =&gt; {}, None =&gt; {} }</code>.CaA parenthesized expression: <code>(a + b)</code>.GaA range expression: <code>1..2</code>, <code>1..</code>, <code>..2</code>, <code>1..=2</code>, <code>..=2</code>.BnA tuple expression: <code>(a, b, c, d)</code>.CdA unary operation: <code>!x</code>, <code>*x</code>.BnA while loop: <code>while expr { ... }</code>.BlA yield expression: <code>yield expr</code>.EdAn <code>impl Bound1 + Bound2 + Bound3</code> type where <code>Bound</code> is a \xe2\x80\xa6CeAn inherited visibility, which usually means private.DcAn iterator over owned pairs of type <code>Pair&lt;T, P&gt;</code>.AlThe <code>*=</code> operatorBoA name-value pair within an attribute, like \xe2\x80\xa6o<code>%=</code>DhA referencing operation: <code>&amp;a</code> or <code>&amp;mut a</code>.DoA reference type: <code>&amp;&#39;a T</code> or <code>&amp;&#39;a mut T</code>.AlThe <code>%=</code> operatorAa<code>self</code>BcThe <code>&lt;&lt;=</code> operatorBcThe <code>&gt;&gt;=</code> operatorAlThe <code>-=</code> operatorCiA single token or a delimited sequence of token trees \xe2\x80\xa6CdReturned by <code>TypeGenerics::as_turbofish</code>.BmA fixed size array type: <code>[T; n]</code>.BmA type contained within invisible delimiters.CnIndication that a type should be inferred by the compiler: \xe2\x80\xa6AmA macro in the type position.AoThe never type: <code>!</code>.CmA generic type parameter: <code>T: Into&lt;String&gt;</code>.CbA parenthesized type equivalent to the inner type.CaA dynamically sized slice type: <code>[T]</code>.BmA tuple type: <code>(A, B, C, String)</code>.DgIf the cursor is pointing at a <code>Group</code>, returns a cursor \xe2\x80\xa6CnParse a set of square brackets and expose their content to \xe2\x80\xa6CkThe span of the invocation of the current procedural macro.AbCharacter literal.CjReturns the punctuation used as the delimiter for this \xe2\x80\xa6CcMutably borrows the first element in this sequence.CkIf this path consists of a single ident, returns the ident.DbIterator over the lifetime parameters in <code>self.params</code>.EmThe <code>for&lt;&#39;a&gt;</code> in <code>for&lt;&#39;a&gt; Foo&lt;&amp;&#39;a T&gt;</code>BmAny lifetimes from a <code>for</code> bindingCmReturns an iterator over the contents of this sequence as \xe2\x80\xa6BiParses any identifier including keywords.CkParse a string of Rust code into the chosen syntax tree \xe2\x80\xa60CiRemoves the trailing punctuation from this punctuated \xe2\x80\xa6CnMutably borrows the punctuation from this punctuated pair, \xe2\x80\xa6CnReturns the span pointing to the opening delimiter of this \xe2\x80\xa6Algithub\xe2\x80\x82crates-io\xe2\x80\x82docs-rsCnWrite <code>self</code> to the given <code>TokenStream</code>.CmMutably borrows the syntax tree node from this punctuated \xe2\x80\xa6CiAn equality constraint on an associated constant: the \xe2\x80\xa60ClA const generic parameter: <code>const LENGTH: usize</code>.DeAn associated type bound: <code>Iterator&lt;Item: Display&gt;</code>.0CiA struct input to a <code>proc_macro_derive</code> macro.CeAn assignment expression: <code>a = compute()</code>.ClA binary operation: <code>a + b</code>, <code>a += b</code>.CkAn array literal constructed from one repeated element: \xe2\x80\xa6CmA <code>return</code>, with an optional value to be returned.CoA struct literal expression: <code>Point { x: 1, y: 1 }</code>.BmAn unsafe block: <code>unsafe { ... }</code>.BgA field-value pair in a struct literal.CeA byte string literal: <code>b&quot;foo&quot;</code>.CmSupport for checking the next token in a stream to decide \xe2\x80\xa6CnA method call expression: <code>x.foo::&lt;T&gt;(a, b)</code>.Ef<strong>A punctuated sequence of syntax tree nodes of type <code>T</code> </strong>\xe2\x80\xa6DiA visibility level restricted to some path: <code>pub(self)</code> or \xe2\x80\xa6BdReturn type of a function signature.CaCursor state associated with speculative parsing.BlA trait used as a bound on a type parameter.ChA bare function type: <code>fn(usize) -&gt; bool</code>.n<code>_</code>DeThe visibility level of an item: inherited or <code>pub</code> or \xe2\x80\xa6CiAdvance this parse stream to the position of a forked \xe2\x80\xa6CaFor use by <code>ToTokens</code> implementations.AfThe type being boundedDhReturns an object that holds this group\xe2\x80\x99s <code>span_open()</code> andCmReturns an iterator over the contents of this sequence as \xe2\x80\xa6CkProduces this punctuated pair as a tuple of syntax tree \xe2\x80\xa6ClExtracts the syntax tree node from this punctuated pair, \xe2\x80\xa6CmCreates a new span with the same name resolution behavior \xe2\x80\xa6CmConstructs a helper for peeking at the next token in this \xe2\x80\xa6ChThe span located at the invocation of the procedural \xe2\x80\xa6CfParse the arguments to the attribute as a syntax tree.BgSee <code>Attribute::parse_args</code>.CdParse the tokens within the macro invocation\xe2\x80\x99s \xe2\x80\xa6CdInvoke parser on the content of this string literal.CkA punctuated sequence of syntax tree nodes separated by \xe2\x80\xa6CgAppends a trailing punctuation onto the end of this \xe2\x80\xa6CnAppends a syntax tree node onto the end of this punctuated \xe2\x80\xa6CnReturns the span pointing to the closing delimiter of this \xe2\x80\xa6DkIf the cursor is pointing at a <code>TokenTree</code>, returns it along \xe2\x80\xa6AlThe <code>|=</code> operatorCnData structure sent to a <code>proc_macro_derive</code> macro.C`A closure expression: <code>|a, b| a + b</code>.CaA for loop: <code>for pat in expr { ... }</code>.EkAddress-of operation: <code>&amp;raw const place</code> or <code>&amp;raw mut place</code>.CfNamed fields of a struct or struct variant such as \xe2\x80\xa6BbAn unspecified invalid expression.Ad<code>( ... )</code>BoCursor position within a buffered token stream.AoInput to a Syn parser function.CkA segment of a path together with any path arguments on \xe2\x80\xa6DiExtensions to the <code>ParseStream</code> API to support speculative \xe2\x80\xa6CnA buffer that can be efficiently traversed multiple times, \xe2\x80\xa6CfAn abstract stream of tokens, or more concretely a \xe2\x80\xa6DgA trait object type <code>dyn Bound1 + Bound2 + Bound3</code> where \xe2\x80\xa6C`A <code>where</code> clause in a definition: \xe2\x80\xa6AdByte string literal.DkThe colon in <code>Struct { x: x }</code>. If written in shorthand like \xe2\x80\xa6CgExtensions to the parsing API with niche applicability.CmCreates a new suffixed integer literal with the specified \xe2\x80\xa6ClCreates an error with the specified message spanning the \xe2\x80\xa6CeParses zero or more inner attributes from the stream.BeParses a named (braced struct) field.CeParses zero or more outer attributes from the stream.DiQuasi-quotation macro that accepts input like the <code>quote!</code> \xe2\x80\xa6Algithub\xe2\x80\x82crates-io\xe2\x80\x82docs-rsClCreates a new span with the same line/column information \xe2\x80\xa6CmReturns the source text behind a span. This preserves the \xe2\x80\xa6CnIterator over the type parameters in <code>self.params</code>.9DjExtensions to the <code>ParseStream</code> API to support manipulating \xe2\x80\xa6CdThe variadic argument of a function pointer like \xe2\x80\xa6B`The <code>&amp;=</code> operatorAlThe <code>^=</code> operatorC`A <code>continue</code>, with an optional label.BfA try block: <code>try { ... }</code>.CiA generic type parameter, lifetime, or const generic: \xe2\x80\xa6CbReturned by <code>Generics::split_for_impl</code>.0EaTurn a type\xe2\x80\x99s generics like <code>&lt;X, Y&gt;</code> into a turbofish like \xe2\x80\xa6BoParses the literal into a selected number type.DbIterator over the constant parameters in <code>self.params</code>.BoExplicit discriminant: <code>Variant = 1</code>BnCreates a new suffixed floating-point literal.0CfFormatting macro for constructing <code>Ident</code>s.CmCreates a new suffixed integer literal with the specified \xe2\x80\xa600CiWhether the character has the Unicode property XID_Start.DkError if this is a <code>Meta::Path</code> or <code>Meta::NameValue</code>.DhPublic implementation details for the <code>TokenStream</code> type, \xe2\x80\xa6CkCopies all remaining tokens visible from this cursor into a444DjIn some positions, types may not contain the <code>+</code> character, \xe2\x80\xa6DhA referencing operation: <code>&amp;a</code> or <code>&amp;mut a</code>.CmUnnamed fields of a tuple struct or tuple variant such as \xe2\x80\xa6D`Specialized formatting trait used by <code>format_ident!</code>.DeA lifetime definition: <code>&#39;a: &#39;b + &#39;c + &#39;d</code>.BoA name-value pair within an attribute, like \xe2\x80\xa6DaThe <code>(A, B) -&gt; C</code> in <code>Fn(A, B) -&gt; C</code>.ChAngle bracketed or parenthesized arguments of a path \xe2\x80\xa6CdA type predicate in a <code>where</code> clause: \xe2\x80\xa6EdAn <code>impl Bound1 + Bound2 + Bound3</code> type where <code>Bound</code> is a \xe2\x80\xa6DoA reference type: <code>&amp;&#39;a T</code> or <code>&amp;&#39;a mut T</code>.DiA visibility level restricted to some path: <code>pub(self)</code> or \xe2\x80\xa6CmCreates a new suffixed integer literal with the specified \xe2\x80\xa6CeCreates a new unsuffixed integer literal with the \xe2\x80\xa6DbIterator over the lifetime parameters in <code>self.params</code>.CjParse a set of parentheses and expose their content to \xe2\x80\xa6BgParses an unnamed (tuple struct) field.DgSame as <code>quote!</code>, but applies a given span to all tokens \xe2\x80\xa6CnAn error if this path is not a single ident, as defined in \xe2\x80\xa665Algithub\xe2\x80\x82crates-io\xe2\x80\x82docs-rsEfThe <code>&lt;&#39;a, T&gt;</code> in <code>core::slice::iter&lt;&#39;a, T&gt;</code>.DiA set of bound lifetimes: <code>for&lt;&#39;a, &#39;b, &#39;c&gt;</code>.CnA method call expression: <code>x.foo::&lt;T&gt;(a, b)</code>.DiA grouping token that surrounds a macro body: <code>m!(...)</code> or \xe2\x80\xa6CjTokenStream extension trait with methods for appending \xe2\x80\xa6ChA trait or lifetime used as a bound on a type parameter.EnA single predicate in a <code>where</code> clause: <code>T: Deserialize&lt;&#39;de&gt;</code>.AgByte character literal.ClDefine a type that supports parsing and printing a given \xe2\x80\xa6C`Creates a new unsuffixed floating-point literal.0CeCreates a new unsuffixed integer literal with the \xe2\x80\xa600CmCreates a new suffixed integer literal with the specified \xe2\x80\xa6CnSplit a type\xe2\x80\x99s generics into the pieces required for impl\xe2\x80\xa6CkDetermines whether this punctuated sequence ends with a \xe2\x80\xa63332BoUnused, but reserved for RFC 3323 restrictions.FcAn individual generic argument, like <code>&#39;a</code>, <code>T</code>, or <code>Item = T</code>.CmContext for parsing a single property in the conventional \xe2\x80\xa6DgA trait object type <code>dyn Bound1 + Bound2 + Bound3</code> where \xe2\x80\xa67CeWhether the character has the Unicode property XID\xe2\x80\xa6ChParse the arguments to the attribute using the given \xe2\x80\xa6BlSee <code>Attribute::parse_args_with</code>.CdParse the tokens within the macro invocation\xe2\x80\x99s \xe2\x80\xa6DhParse a <code>Path</code> containing no path arguments on any of its \xe2\x80\xa6DjConvert <code>self</code> directly into a <code>TokenStream</code> object.0CnIterator over the type parameters in <code>self.params</code>.>CaFor use by <code>ToTokens</code> implementations.DbIterator over the constant parameters in <code>self.params</code>.Cjin order to find the highest pair, we need to find the \xe2\x80\xa6CeCreates a new unsuffixed integer literal with the \xe2\x80\xa6DbParses zero or more occurrences of <code>T</code> separated by \xe2\x80\xa60DaRender the error as an invocation of <code>compile_error!</code>.2EjA lifetime predicate in a <code>where</code> clause: <code>&#39;a: &#39;b + &#39;c</code>.6DkReturns true if either this <code>Punctuated</code> is empty, or it has \xe2\x80\xa699DfInitializes an empty <code>where</code>-clause if there is not one \xe2\x80\xa6ChParse the input TokenStream of a macro, triggering a \xe2\x80\xa6CiParse the arguments to the attribute, expecting it to \xe2\x80\xa6BnSee <code>Attribute::parse_nested_meta</code>.EjUsed when parsing <code>list(...)</code> syntax <strong>if</strong> the content inside \xe2\x80\xa6DkError if this is a <code>Meta::List</code> or <code>Meta::NameValue</code>.DkA modifier on a trait bound, currently only used for the <code>?</code> \xe2\x80\xa6CfDefine a type that supports parsing and printing a \xe2\x80\xa6:DfError if this is a <code>Meta::Path</code> or <code>Meta::List</code>.CkReturns the delimiter, the span of the delimiter token, \xe2\x80\xa6DfThis macro is <code>parse_quote!</code> + <code>quote_spanned!</code>.DkParses zero or more occurrences of <code>T</code> using the given parse \xe2\x80\xa6DaParses one or more occurrences of <code>T</code> separated by \xe2\x80\xa6DlArguments of a function path segment: the <code>(A, B) -&gt; C</code> in \xe2\x80\xa6DjParses one or more occurrences of <code>T</code> using the given parse \xe2\x80\xa6EaAngle bracketed arguments of a path segment: the <code>&lt;K, V&gt;</code> in \xe2\x80\xa6")